# 排序

## 冒泡排序

两个两个相互比较,  每次将最大或者最小的元素移动到末尾

## 插入排序

类比打纸牌的时候, 让前面先有序, 之后每新增一个元素就从后向前不断地比较, 看哪个位置合适, 不合适就向后移动

## 选择排序

先确定位置, 比如我需要确定第一个元素的值, 那我就找到从第二个元素开始的最小值, 交换第一个元素和这个最小值

## 希尔排序

分组进行插入排序

长度为 $n$ 那么每次的分组为 $a = \left \lfloor \frac{n}{2} \right \rfloor $ $b = \left \lfloor \frac{a}{2} \right \rfloor$ $c = \left \lfloor \frac{b}{2} \right \rfloor$ $\dots$

优点, 减少了移动的距离和次数

## 快速排序

有类似归并排序的思想, 维护两个指针, 我们分别叫他指针 $i$ , $j$ , 我们要确定指针 $i$ 的值的正确位置, 我们就认为指针 $i$ 指向空白

之后移动另一个非空白的指针, 之后找到合适元素交换即可, 最后两个指针相等, 那么原值存放于此

其实要排序的序列分为两个区间, 递归即可

## 堆排序

使用二叉树来排序(完全二叉树)[这个二叉树是不能单独有右儿子的]

从最后一个非叶子节点($\frac{n}{2} - 1$)的根节点开始, 如果这个节点没有比儿子节点大, 就用儿子节点中最大的与之交换, 否则就节点序号-1继续做判断

注意交换后要持续比较



# 二叉树遍历

## 先序遍历

**根 -> 左子树 -> 叶子 -> 右子树**

**前序遍历：根左右**

```c++
void Pre_order(lli index){
	if(tree[index].content == NULL) return;
	printf("%c", tree[index].content);
	Pre_order(index << 1);
	Pre_order(index << 1 | 1);
}
```

## 中序遍历

**左子树都在根节点的左边，右子树都在根节点的右端**

**中序遍历：左根右**

```c++
void In_order(lli index){
	if(tree[index].content == NULL) return;
	In_order(index << 1);
	printf("%c", tree[index].content);
	In_order(index << 1 | 1);
}
```

## 后序遍历

**把左右子树全部打印完后才会打印自身**

**后序遍历：左右根**

```c++
void Post_order(lli index){
	if(tree[index].content == NULL) return;
	Post_order(index << 1);
	Post_order(index << 1 | 1);
	printf("%c", tree[index].content);
}
```

## 推断

自己现场推断, 注意, 必须要有中序遍历



# 树、森林、二叉树的相互转换

## 树转化为二叉树

<img src="C:/Users/%E9%98%B4%E9%93%AD%E6%B4%8B/AppData/Roaming/Typora/typora-user-images/image-20231229155128010.png" alt="image-20231229155128010" style="zoom:80%;" />

## 森林转化为二叉树

<img src="C:/Users/%E9%98%B4%E9%93%AD%E6%B4%8B/AppData/Roaming/Typora/typora-user-images/image-20231229155253633.png" alt="image-20231229155253633" style="zoom:80%;" />

## 二叉树转换为树

将二叉树转化为水平， 时候加线后再去掉兄弟节点的线， 之后链接即可

总结 ： 树转化为二叉树的逆过程

<img src="https://pic3.zhimg.com/v2-56ed8579aa801c5a27bf54fd74264bfa_b.webp" alt="动图" style="zoom:50%;" />

## 二叉树转换为森林

**删除右孩子连线。**

从根节点开始，**若右孩子存在**，则**把与右孩子结点的连线删除**。再查看分离后的二叉树，若其根节点的右孩子存在，则连续删除。直到所有这些根结点与右孩子的连线都删除为止。

<img src="https://pic4.zhimg.com/v2-707f004bb9513f7332e25c1ab9e322e7_b.webp" alt="动图" style="zoom: 50%;" />

**将每棵分离后的二叉树转换为树**。



# 最小生成树

边的权值之和小于或者等于其它生成树的边的权值之和。

## Prime算法（$m\log n$）

> 点寻找 ：

```c++
typedef long long int lli;
lli RoadNum, NodeNum, Begin;
const int N = 10000;
vector<pair<lli,lli>> graph[N];
bitset<N> Check;
struct cmp{
    bool operator() (pair<lli,lli>a, pair<lli,lli>b){
        return a.second > b.second;
    }
};
priority_queue<pair<lli,lli>, vector<pair<lli,lli>>, cmp> Find;
signed main()
{
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin >> NodeNum >> RoadNum;
    //存图
    for(lli temp = 1, num1 ,num2, num3; temp <= RoadNum ; temp++){
        cin >> num1 >> num2 >> num3;
        graph[num1].push_back(make_pair(num2, num3));
        graph[num2].push_back(make_pair(num1, num3));
        Begin = num1;
    }
    //算法开始
    //从Begin这个开始寻找，后面的值代表到这里所需要的值，初始为0
    Find.push(make_pair(Begin, 0));
    // ans表示最小生成树的值， Count计算点集的个数，判断是否都包含
    lli ans = 0LL, Count = 0LL;
    while(!Find.empty()){
        auto node = Find.top(); Find.pop();
        if(Check[node.first]) continue; // 如果这个点已经在点集内，不加入
        Count++;
        Check[node.first] = 1;
        ans += node.second;
        for(auto pr : graph[node.first]){
            if(Check[pr.first]) continue;
            // 将这个点所有的连通点且未在点集的加入优先队列
            Find.push(make_pair(pr.first, pr.second));
        }
    }
    if(Count == NodeNum) cout << ans; //如果最小生成树不包含所有的点，不连通
    else cout << "orz";
    return 0;
}
```



## Kruskal算法（$m\log m$）

> 边寻找

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long int lli;
const int N = 10000;
lli NodeNum, RoadNum;
vector<tuple<lli,lli,lli>> road;
vector<lli> pre(N);
void init(){
    for(int temp = 1 ; temp <= NodeNum + 10 ; temp++)
        pre[temp] = temp;
}
lli Find_set(lli index){
    if(index == pre[index]) return index;
    pre[index] = Find_set(pre[index]);
    return pre[index];
}
bool Join_set(lli one, lli two){
    // 返回类型为bool用于判断
    lli root1 = Find_set(one), root2 = Find_set(two);
    if(root1 == root2) return 0;
    pre[root1] = root2;
    return 1;
}
signed main()
{
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin >> NodeNum >> RoadNum;
    init();
    //存图
    for(lli temp = 1, num1, num2, num3; temp <= NodeNum ; temp++){
        cin >> num1 >> num2 >> num3;
        road.push_back(make_tuple(num2, num1, num3));
        road.push_back(make_tuple(num1, num2, num3));
    }
    //算法开始
    auto cmp = [](tuple<lli,lli,lli>a, tuple<lli,lli,lli>b) {return get<2>(a) < get<2>(b);};
    //将边权从小到大排序
    sort(road.begin(), road.end(), cmp);
    // 统计最小生成树的权值，并且记录包含的点的数量，为了方便计算，从1开始
    lli ans = 0LL, Node = 1LL;
    for(auto pr : road){
        if(Node == NodeNum) break; //如果所需点数够了，结束
        lli one = get<0>(pr), two = get<1>(pr), there = get<2>(pr);
        if(Join_set(one, two)){ // 如果边两边链接的并未包含在一起， 链接
            Node++;
            ans += there;
        }
    }
    if(Node != NodeNum) cout << "orz"; //不够点就是图不连通
    else cout << ans;
    return 0;
}
```



# 二叉排序树

```c++
#include<bits/stdc++.h>
#define UDF 0xffffffff
using namespace std;
typedef unsigned long long int ull;
typedef long long int lli;
const int N = 2e5 + 10;
lli total_ask, Length, Limit, Num1, Num2, Num3;
vector<lli> arr(N);
vector<lli> Tree(N);
// 比当前节点小就放在左边否则放在右边, 要注意是升序还是降序
void build(lli num, lli i) {
    if(Tree[i] == UDF) {
        Tree[i] = num; return;
    }
    if(num <= Tree[i])
        build(num, i << 1);
    else build(num, i << 1 | 1);
}
// 中序遍历
void in_order(int i) {
    if(Tree[i] == UDF) return;
    in_order(i << 1);
    cout << Tree[i] << " ";
    in_order(i << 1 | 1);
}
signed main()
{
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin >> Length;
    for(int i = 1 ; i <= Length ; i ++) 
        cin >> arr[i];
    for(int i = 0 ; i < N ; i ++)   Tree[i] = UDF;
    for(int i = 1 ; i <= Length ; i ++)
        build(arr[i], 1);
    in_order(1);
}
```

## 删除操作

二叉排序树的删除操作可以分为三种情况:
1.要删除的节点是叶子节点: 直接将该节点删除即可。
2.要删除的节点只有一个子节点: 将该节点的子节点与其父节点连接，并删除该节点
3.要删除的节点有两个子节点: 找到该节点的中序遍历的前驱(或后继)节点，将前驱(或后继)节点的值替换到要删除的节点中, 然后递归删除前驱(或后继)节点即可

```c++
void delete_ele(int ele, int i) {
    // 找到那个节点
    if(Tree[i] != ele) {
        if(ele <= Tree[i])
            delete_ele(ele, i << 1);
        else delete_ele(ele, i << 1 | 1);
        return;
    }
    // 节点为叶子节点
    if(Tree[i << 1] == UDF && Tree[i << 1 | 1] == UDF) {
        Tree[i] = UDF; return;
    }
    // 只有一个子节点, 那么就不断递归
    if((Tree[i << 1] == UDF) ^ (Tree[i << 1 | 1] == UDF)) {
        int pos = i << 1 | (!(Tree[i << 1 | 1] == UDF));
        swap(Tree[i], Tree[pos]); delete_ele(ele, pos);
        return;
    }
    // 两个都有就递归左节点
    swap(Tree[i], Tree[i << 1]);
    delete_ele(ele, i << 1);
}
```

# 平衡二叉树

平衡二叉树是特殊的二叉排序树, 并且平衡因子的绝对值小于等于 $1$

平衡因子 : 左子树的高度 - 右子树的高度

