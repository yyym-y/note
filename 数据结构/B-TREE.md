# B-Tree （做人要有 B-树）

## 引入

​		初识 B-Tree是因为手写 Mysql 数据库时遇到了索引，为了能够更高效率的查询数据，索引也必须要可以高效率的查询，在 Mysql 数据库中，是使用 B+ Tree的， 而作为 B+ Tree的老爸 B-Tree， 自然有必要好好的了解一样

​		你也许会疑惑，为什么一定要选择 B+ Tree 作为索引的数据结构，红黑树等等也可以做到在优秀的时间复杂度查询到数据，哪有为啥一定要大费周章呢？

​		你也许会知道，索引文件大部分都是存在磁盘之中的，而 CPU 要想读取数据是只能从内存中读取的，所以就需要从磁盘中将数据读到内存之中，CPU 再从内存中读取数据完成逻辑。 我们将从磁盘读到内存的过程叫做 I / O 操作。

<img src="D:/DeskTop/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E8%AF%BB%E5%8F%96.png" alt="读取"  />

​		众所周知， I / O 操作是十分慢的，每一次从磁盘中读取数据都是十分的耗费时间， 所以为了更好的提高效率，我们就必须减少读取的次数。

​		现在假设我们要存储 $10000000$ 条数据， 如果你是使用红黑树等等二叉树系， 那么在最优的情况下， 深度会来到 $\left \lceil \log_2 (10000000) \right \rceil  = 24$ 层， 也就是如果要查询最底层的数据，要进行 $24$ 次 I / O 操作，会浪费大量时间。

​		如果使用多叉树， 就比如 B - Tree ， 如果是最大度数是 $7$ （实际上远大于这个数）， 那么层数就会大大缩减，来到 $\left \lceil \log_7 (10000000) \right \rceil  = 8$ 层， 这样就大大减少了 I / O操作次数。



## B - Tree 的特点

关于 B - Tree， 它有着属于自己的规则， 至于这些规则是为什么，你可以理解为让整个树更加平衡，提高效率。

规则如下 ：

* 所有的叶子节点都在同一层  （即不存在叶子节点一高一低的状态）

* B - 树有个最小度 $t$ ， $t$ 的值依赖于磁盘一页的大小，是其整数倍， 大概是 4kb 或 16kb 也许...
* 所有树节点（除了根节点）都最少要有 $t-1$ 个关键字， 根节点至少有一个关键字
* 所有节点（包括根节点）最多只能有 $2t-1$ 个关键字
* 某个节点的子节点个数为其自身关键字数量 + $1$
* 所有节点内的关键字递增
* 在关键字  $K_1$ 和 $K_2$ 之间的所有子树上的节点关键字值都在 $K_1$ 和 $K_2$ 之间 （和搜索二叉树一致）



由上面这些规则，我稍微总结了一下一个我们需要记住的点 ：

> 假设某一个节点的关键字数量为 $\alpha$ , 那么 ： $t - 1 \le \alpha \le 2t - 1$
>
> 这个节点有 $\alpha + 1$ 个儿子



简单展示一下，这是一个 $t=2$ 的 B - Tree

![B-Tree__t=3](D:/DeskTop/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/B-Tree__t=3.png)

国内的教材大多以算阶为主，那么也简要的介绍一下阶 （PS： 上面这个图的最大阶数是 $3$）

阶数和度数的关系如下 ：

> 阶数 =  2 $\times$ 度数 $-$ 1



## B - Tree 的操作

这里先推荐一个数据结构可视化的网站 ： [Data Structure Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

B - Tree in this way sir ~~  [B-Tree Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/BTree.html)

大家可以使劲造....



### B - Tree 的插入

凡是要从最简单的开始，于是我们从最简单的开始：

PS ： 一下演示的所有 B-Tree 的度数均为 $2$ 即每个节点的关键字数量为 $1 \le \alpha \le 3$



1.  如果我们插入后依然满足 B - Tree 的性质， 那么我们就直接插入就好了

<img src="D:/DeskTop/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E7%AE%80%E5%8D%95%E6%8F%92%E5%85%A5.png" alt="简单插入"  />

2. 如果插入后不满足，那我们就分裂，同时将中间的值添加到父亲节点，同时再检查父亲，以此类推

![分裂](D:/DeskTop/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E5%88%86%E8%A3%82.png)

图片描述的可能不会很清晰，所以笔者尝试用语言描述的更加细致 ：

> 插入值为 $v$ 的关键字， 关键字最多有 $m - 1$ 个

插入的位置一定是在叶子节点，所以我们先向下遍历寻找某一个可以放下值 $v$ 的叶子节点

1.  如果在向下遍历的过程中找到了值 $v$ ， 证明已经存在该值，直接返回

遍历到了某一个符合条件的叶子节点 ：

1. 这个叶子节点的空间足够（插入该节点后关键字的个数小于 $m$）
   1. 直接插入该元素在合适的位置 （主要递增）
2. 这个叶子节点的空间满了没有空间添加新的元素了
   1.  将这个叶子的所有值和要插入的值看成一个整体， 取出这个整体的中间值
   2. 小于这个中间值的数单独作为一个节点连到父节点上， 大于这个中间值的数作为另一个节点
   3. 这个中间值插到父亲节点上
      1. 如果父亲节点插上这个值后符合条件 $\Longrightarrow$ 结束
      2. 超出范围就接着分裂， 按照我们上面的分裂规则分裂（可能分裂到根节点）
      3. 如果分裂到根节点，就将树的深度加一，创建一个新的根节点（只有一个关键字）



阿巴阿巴了那么多，大家可以去可视化网站上使劲造了...

如果没听懂，笔者只能说声抱歉了，实力有限，知乎上还有大量的图形演示，也许可助君一臂之力



### B - Tree 的删除

B - Tree 的删除也许是整个 B - Tree 部分最晦涩难懂的部分了

笔者也不能偷懒了，也要分情况多画图了...

PS ： 一下演示的所有 B-Tree 的度数均为 $2$ 即每个节点的关键字数量为 $1 \le \alpha \le 3$



> 我们先假设删除的是叶子节点（其他情况也可以转化为删除叶子节点）

我们先从最简单的情况考虑，删除后依然满足条件：

![简单删除](D:/DeskTop/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E7%AE%80%E5%8D%95%E5%88%A0%E9%99%A4.png)

接下来分析如果删除后不满足条件的情况：

我们要分两种情况考虑 : 

1. 如果你的兄弟节点是丰满的（即少一个关键字依然满足条件） ：

![兄弟富有](D:/DeskTop/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E5%85%84%E5%BC%9F%E5%AF%8C%E6%9C%89.png)

2. 兄弟都是穷鬼，甚至父亲也是穷鬼

PS ： 此例中的最大阶数为 $5$ ， 即每个节点的关键字数量为 $2 \le \alpha \le 4$

我们想要删除 $5$

![删除1](D:/DeskTop/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E5%88%A0%E9%99%A41.png)

这个时候我们去掉 $5$ 从父亲节点处借了一个关键字 $4$ ， 接着观察兄弟节点是否富有

结果发现都是穷鬼， 那没办法了，被删除的节点于相邻的节点合并

![删除2](D:/DeskTop/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E5%88%A0%E9%99%A42.png)

但这个时候父亲是不满足条件的，于是父亲看看自己的兄弟节点有没有富有的，结果发现没有

于是有按照老套路，拿走自己父亲的关键字，接着合并自己的兄弟节点

![删除3](D:/DeskTop/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E5%88%A0%E9%99%A43.png)

![删除4](D:/DeskTop/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E5%88%A0%E9%99%A44.png)

至此，全部符合条件，删除完成。

笔者接着尝试用语言来描述这个过程 ：

> 假设我们要删除关键字 $v$ ， $v$ 存在叶子节点

向下递归寻找关键字 $v$ 

1. 发现叶子节点不存在 $v$ ，删除为非法操作， 结束

找到了关键字 $v$ ， 并删掉了这个值

1. 如果删除后，这个节点依然满足 B - Tree 的条件， 删除结束， 返回
2. 删除后过少， 先从父亲节点借一个相邻的值补上，使这个节点符合条件
   1. 观察被删除的兄弟节点是否存在富有的情况（即失去一个依然满足条件）
      1. 让这个富有的兄弟节点给出一个合适的关键字给父亲节点，补上空缺
   2. 如果全部都是贫穷的
      1. 让关键字 $v$ 所在的节点于其相邻的节点合并
      2. 将这个不符合条件的父亲节点看成一个被删除的节点，再向它的父亲伸手要关键字
      3. 如果父亲的父亲节点失去一个关键字后满足条件， 则删除过程结束
      4. 不满足的话，父亲节点于兄弟节点合并，接着把父亲的父亲看成被删除的节点，重复2-4步骤
      5. 如果递归到了根节点， 那么树的深度减一



> 删除的不是叶子节点

我们可以将这个节点转化为叶子节点

![删除非叶子](D:/DeskTop/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E5%88%A0%E9%99%A4%E9%9D%9E%E5%8F%B6%E5%AD%90.png)

语言描述如下 ：

​		如果我们删除的是一个非叶子节点，那么找到它相邻的下一个元素：「左孩子最右边的节点」或「右孩子最左边的节点」， 将这个元素替换到要删除的位置上，那么就可以看成删除替换的元素

​		那么要删除的元素层数就加深了，最后一定能递归到叶子节点。



