# chapter3.0-传输层

## 概述

运输层协议为不同主机上的 **进程** 之间实现了逻辑通信

发送方会将应用层的数据拆封成 **报文段(segment)** , 然后传递给网络层

接受方会接收网络层的数据并重组为报文段, 然后传递给应用层

传输层有许许多多的协议, 在 Internet 中主要是 **UDP** 和 **TCP**

### 应用层 VS 传输层

网络层服务：主机之间的逻辑通信

传输层服务：进程间的逻辑通信

- 依赖于网络层的服务：延时、带宽
- 并对网络层的服务进行增强：数据丢失、顺序混乱、加密
- 有些服务是可以加强的：不可靠 -> 可靠；安全
- 但有些服务是不可以被加强的：带宽，延迟



### Internet传输层协议

前面讲到, Internet传输层的协议主要有两种 **UDP** 和 **TCP** , 他们有如下的区别:

**可靠的、保序的传输：TCP**

> 多路复用、解复用
>
> 拥塞控制
>
> 流量控制
>
> 建立连接

**不可靠、不保序的传输：UDP**

> 多路复用、解复用
>
> 没有为尽力而为的IP服务添加更多的其它额外服务

**都不提供的服务：**

> 延时保证
>
> 带宽保证

补充 : 我们知道, 在传输层下面的网络层的 IP 服务是尽力而为交付服务, 是不可靠的, 而在传输层之上是可以提供可靠的服务的, 所以需要传输层操作, 定义相关的协议规定,尽可能让传输层传递的数据是可靠的



## 多路复用/解复用

<img src="./img/chapter3-0.png" alt="chapter3-0" style="zoom:80%;" />

简单解释一下什么叫多路复用和解复用

多路复用:

对于传输层来说, 他会接收许许多多来自应用层的数据, 他们可能来自不同的端口, 而多路复用值得是 : 传输层会将这些信息封装, 将他们统一成一个逻辑体, 传输层对这些封装了不同端口信息的逻辑体一视同仁, 并将他们转发至网络层

解复用:

传输层收到这些封装了不同端口的逻辑体, 将其中的端口信息拆分出来, 之后让指定的端口接收信息

### 多路复用/解复用的原理

主要还是依赖 `socket` 来实现

一个 TCP / UDP 的报文段基本形式如下图所示 :

<img src="./img/chapter3-1.png" alt="chapter3-1" style="zoom:80%;" />

#### UDP 原理

UDP 的 `socket` 包含以下字段 : 标识符, 目的IP地址, 目的端口号, PID

创建 UDP socket:

```python
clientSocket = socket(AF_INET, SOCK_DGRAM)
```

没有Bind,ClientSocket和OS为之分配的某个端口号捆绑（客户端使用什么端口号无所谓，客户端主动找服务器）

1. 当主机收到UDP报文段：
   - 检查报文段的目标端口号
   - 用该端口号将报文段定位给套接字
   - 套接字表示 PID, 最后交付到对应进程
2. 如果两个不同源IP地址/源端口号的数据报，但是有相同的目标IP地址和端口号，则被定位到相同的套接字



#### TCP 原理

TCP 的 `socket` 包含以下字段 : 标识符, 源IP地址, 源端口号, 目的IP地址, 目的端口号, PID

传输层会同时比较 源IP地址, 源端口号, 目的IP地址, 目的端口号这四个值来精确确定一个目标socket





## 无连接运输: UDP

UDP 的特点:

> “no frills,” “bare bone”Internet 传输协议
>
> “尽力而为”的服务，报文段可能：**丢失 , 送到应用进程的报文段乱序**
> 无连接：**UDP发送端和接收端之间没有握手 , 每个UDP报文段都被独立地处理**
> UDP被用于： **流媒体（丢失不敏感，速率敏感、应用可控制传输速率）DNS SNMP**
> 在UDP上可行可靠传输: **在应用层增加可靠性, 应用特定的差错恢复**



UDP 的优点 : 

1. 不建立连接（会增加延时）
2. 简单：在发送端和接收端没有连接状态
3. 报文段的头部很小(开销小)
4. 无拥塞控制和流量控制：UDP可以尽可能快的发送报文段
   - 应用->传输的速率= 主机->网络的速率



### UDP 校验和

校验和主要是判断数据是否在传输过程中被破坏

校验和的位数一般是 $16$ 位

[轻松掌握UDP校验和 - 混沌奇迹 - 博客园 (cnblogs.com)](https://www.cnblogs.com/young-ma/p/16225829.html)

> 回滚 :
>
> 我们知道两个 $16$ 位的二进制相乘可能会溢出到 $17$ 位, 我们先将计算的结果截取成 $16$ 位
>
> 之后如果有进位就将结果 $+1$



## 可靠数据传输原理

