# 快速幂+组合数学

## 快速幂

### 定义

**快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个以 $O(log⁡(n))$ 的时间复杂度内计算 $a^n$ 的小技巧，而暴力计算的时间复杂度为 $O(n)$ 。而这个技巧也常常用在非计算的场景，因为它可以应用在任何具有结合律的运算中。其中显然的是它可以应用于模意义下取幂、矩阵幂等运算，我们接下来会讨论。**

![image-20240414154206219](/C:/Users/31097/AppData/Roaming/Typora/typora-user-images/image-20240414154206219.png)

### 模板

```c++
#define int long long
int qpow(int a, int n)
{
    int res = 1;
    while (n)
    {
        if (n & 1) res *= a;
        a *= a;
        n >>= 1;
    }
    return res;
}
```



## 快速幂矩阵

### 矩阵基础

![image-20240414154922830](C:/Users/31097/AppData/Roaming/Typora/typora-user-images/image-20240414154922830.png)

![image-20240414154937657](C:/Users/31097/AppData/Roaming/Typora/typora-user-images/image-20240414154937657.png)

![image-20240414154950787](C:/Users/31097/AppData/Roaming/Typora/typora-user-images/image-20240414154950787.png)



### 矩阵快速幂

**主要由矩阵乘法和快速幂两部分组成**

```c++
#include <bits/stdc++.h>
using namespace std;
#define mod 1000000007
typedef long long ll;
ll n,t;
//定义矩阵结构体
struct Matrix
{
    ll m[5][5];
} ans,base;
Matrix mul(Matrix a, Matrix b)//矩阵乘法
{
    Matrix res;
    memset(res.m, 0, sizeof(res.m));//初始化
    for(int i=1; i<=3; i++)//最大为3*3矩阵，base*base的时候
    {
        for(int j=1; j<=3; j++)
        {
            for(int k=1; k<=3; k++)
            {
                res.m[i][j]+=(a.m[i][k]%mod)*(b.m[k][j]%mod);//第三个矩阵的行数与左边矩阵相等，列数与右边矩阵相等
                res.m[i][j]=(res.m[i][j]%mod+mod)%mod;//防止取模后该数为负数
            }
        }
    }
    return res;
}
//初始化base,ans
void init()
{
    //矩阵1[f(i-1),f(i-2),f(i-3)]
    //初始数列f3=1,f2=1,f1=1
    ans.m[1][1]=1;
    ans.m[1][2]=1;
    ans.m[1][3]=1;
    //矩阵2
    //[2， 1，0]
    //[1， 0，1]
    //[-1，0，0]
    base.m[1][1]=2;
    base.m[1][2]=1;
    base.m[1][3]=0;
    base.m[2][1]=base.m[2][3]=1;
    base.m[2][2]=0;
    base.m[3][2]=base.m[3][3]=0;
    base.m[3][1]=-1;
}
//快速幂
void qpow(ll n)
{
    //传入n次幂
    while(n)
    {
        if(n&1)
            ans=mul(ans,base);//n为奇数
        base=mul(base,base);
        n>>=1;
    }
}
int main()
{
    cin>>t;
    for(int i=1; i<=t; i++)
    {
        cin>>n;
        if(n<=3)
        {
            cout<<1<<endl;
            continue;
        }
        init();//每次初始化矩阵
        qpow(n-3);//快速幂优化
        cout<<ans.m[1][1]%mod<<endl;
    }
    return 0;
}
```



### 例题

•https://www.luogu.com.cn/problem/P1939

•P1939 【模板】矩阵加速（数列）



## 组合数学

### 求组合数

#### 递推法+杨辉三角 ($1 \le n  \le m \le 2000$)

首先这个方法的一个根本来自一个递推关系式：
$$
C_m^n = C_{m-1}^{n} + C_{m-1}^{n - 1}
$$
怎么理解这个式子呢，我们可以用选择的方法来理解：

> $C_m^n$ 代表从$m$ 个数中选择$n$ 个数，这一过程可以分解成两个部分
>
> * 第一个数我不选，那么我将从剩下的$m - 1$ 个数中选择 $n$ 个数， 即 $C_{m - 1}^{n}$
>
> * 第一个数我选，那么我将从剩下的$m - 1$ 个数中选取 $n - 1$ 个数， 即 $C_{m - 1}^{n - 1}$
>
> 所以 $C_m^n = C_{m-1}^{n} + C_{m-1}^{n - 1}$ 

所以我们可以列出一个表格，列表中的数是表中上面和表中左上的两个数 之和

同时我们还可以获得两个结论

> $C_n^1 = C_n^n = 1$
>
> $C_n^m = C_n^{n -m}$

|   0   |   1   |   2    |   3    |   4    |   5    |   6   |   7   | 行号 |
| :---: | :---: | :----: | :----: | :----: | :----: | :---: | :---: | :--: |
| **1** |       |        |        |        |        |       |       |  0   |
| **1** | **1** |        |        |        |        |       |       |  1   |
| **1** | **2** | **1**  |        |        |        |       |       |  2   |
| **1** | **3** | **3**  | **1**  |        |        |       |       |  3   |
| **1** | **4** | **6**  | **4**  | **1**  |        |       |       |  4   |
| **1** | **5** | **10** | **10** | **5**  | **1**  |       |       |  5   |
| **1** | **6** | **15** | **20** | **15** | **6**  | **1** |       |  6   |
| **1** | **7** | **21** | **35** | **35** | **21** | **7** | **1** |  7   |


**代码**

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long int lli;
lli P = 998244353;
lli mod(lli n) {return n % P;}
lli Compute(lli m, lli n){
    vector<lli> dp(m + 10, 0);
    dp[0] = 1;
    for(int temp = 1 ; temp <= m ; temp++){
        for(int temp2 = temp ; temp2 >= 1 ; temp2--)
            dp[temp2] = mod(dp[temp2] + dp[temp2 - 1]);
    }
    return dp[n];
}
signed main()
{
    lli m, n; cin >> m >> n;
    cout << Compute(m, n);
}
```

#### 公式+快速幂（$1 \le n \le m \le 1e5$）

首先我们知道求组合数的具体公式：
$$
C_m^n = \frac{m!}{(m - n)! n!}
$$
所以我们可以提前将这些数算出来，即打表

有因为涉及到除法取模， 所以我们在预处理的时候要另加处理， 我们需要知道 $m!$ 在$P$ 运算下的逆元

有关逆元的相关文章：

[乘法逆元 + 模的除法_yyym__的博客-CSDN博客](https://blog.csdn.net/weixin_73503181/article/details/129099778)

我们可以观察到：

> $\frac{1}{n!} = \frac{1}{n} \cdot \frac{1}{(n - 1)!}$
>
> $\frac{1}{(n-1)!}$ 之前已经算过了， 所以我们只需要求出 $n$ 在$P$ 的逆元
>
> 可以使用费马小定理

**代码**

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long int lli;
lli P = 998244353;
lli mod(lli n) {return n % P;}
lli fast_pow(lli n, lli power){
    lli ans = 1LL;
    while(power){
        if(power & 1) ans = mod(ans * n);
        n = mod(n * n);
        power >>= 1;
    }
    return (ans + P) % P;
}
lli Compute(lli m, lli n){
    vector<lli> info(m + 10, 0), rev(m + 10, 0);
    info[0] = 1; rev[0] = 1;
    for(int temp = 1 ; temp <= m + 1 ; temp++){
        info[temp] = mod(info[temp - 1] * temp);
        rev[temp] = mod(rev[temp - 1] * fast_pow(temp, P - 2));
    }
    return info[m] * rev[n] % P * rev[m - n] % P;
}
signed main()
{
    lli m, n; cin >> m >> n;
    cout << Compute2(m, n);
}

```

#### 卢卡斯定理（$1 \le m \le n \le 1e18$)($1 \le p \le 1e5$)

Lucas 定理用于求解大组合数取模的问题，其中模数必须为素数。
$$
\binom{n}{m}=\binom{n\ mod\ p}{m\ mod\ p} \times \binom{ \lfloor n/p \rfloor}{\lfloor m/p \rfloor}\ mod\ p
$$
模板：

[洛谷:P3807 【模板】卢卡斯定理/Lucas 定理](https://www.luogu.com.cn/problem/P3807)

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int mn = 1e5 + 10;
int f[mn], fi[mn], n, t, p, m;
int qpow(int a, int n)
{
    int res = 1;
    while (n)
    {
        if (n & 1)
            res = (res * a) % p;
        a = (a * a) % p;
        n >>= 1;
    }
    return res;
}

int inv(int a)
{
    return qpow(a, p - 2);
}

void init()
{
    f[0] = fi[0] = 1;
    for (int i = 1; i <= p; i++)
    {
        f[i] = i * f[i - 1] % p;
        fi[i] = inv(f[i]);
    }
}

int C(int n, int m)
{
    if (m > n)
        return 0;
    return f[n] * fi[m] % p * fi[n - m] % p;
}

int Lucas(int n, int m)
{
    if (m == 0)
        return 1;
    return C(n % p, m % p) * Lucas(n / p, m / p) % p;
}

signed main()
{
    cin >> t;
    while (t--)
    {
        cin >> n >> m >> p;
        init();
        cout << Lucas(n + m, m) << endl;
    }
    return 0;
}
```



### 容斥原理

#### 引入

**假设班里有10个学生喜欢数学，15个学生喜欢语文，21个学生喜欢编程，班里至少喜欢一门学科的有多少个学生呢？**

是 $10+15+21=46$ 个吗？不是的，因为有些学生可能同时喜欢数学和语文，或者语文和编程，甚至还有可能三者都喜欢。

为了叙述方便，我们把喜欢语文、数学、编程的学生集合分别用 $A,B,C$ 表示，则学生总数等于 $|A\cup B\cup C|$。刚才已经讲过，如果把这三个集合的元素个数 $|A|,|B|,|C|$ 直接加起来，会有一些元素重复统计了，因此需要扣掉 $|A\cap B|,|B\cap C|,|C\cap A|$，但这样一来，又有一小部分多扣了，需要加回来，即 $|A\cap B\cap C|$。即
$$
|A\cup B\cup C|=|A|+|B|+|C|-|A\cap B|-|B\cap C|-|C\cap A|+|A\cap B\cap C|
$$


![容斥原理 - venn 图示例](https://oi-wiki.org/math/combinatorics/images/incexcp.png)

#### 例1：简单的 RC 签到题

给定素数 $a,b,c,d$, 求 $1$ 到 $n$ 中的整数中至少能整除这 $4$ 个元素中的一个的数有几个？

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n, a, b, c, d, ans;
signed main()
{
    cin >> n;
    cin >> a >> b >> c >> d;
    ans += n / a + n / b + n / c + n / d;
    ans -= n / (a * b) + n / (a * c) + n / (a * d) + n / (b * c) + n / (b * d) + n / (c * d);
    ans += n / (a * b * c) + n / (a * b * d) + n / (a * c * d) + n / (b * c * d);
    ans -= n / (a * b * d * c);
    cout << ans;
    return 0;
}
```



#### (练习)：还是简单的 RC 签到题

求 $[l,r]$ 中与 $n$ 互质的个数

